// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// OAuthClientAuthPolicy OAuth client policy details
//
// swagger:model OAuthClientAuthPolicy
type OAuthClientAuthPolicy struct {
	idField *string

	policyField *string

	// The authorization URL
	// Max Length: 256
	// Pattern: ^[\w-_\:\.\?\/]*$
	AuthorizationURL string `json:"authorizationUrl,omitempty"`

	// The OAuth flows
	// Required: true
	// Max Items: 30
	// Min Items: 1
	Flows []string `json:"flows"`

	// The location of oauth token
	// Max Length: 100
	// Pattern: ^[\w-_\:\.\/]*$
	Location *string `json:"location,omitempty"`

	// Scopes that should be present in access token
	Scopes []*Scope `json:"scopes"`

	// The token URL
	// Max Length: 256
	// Pattern: ^[\w-_\:\.\/]*$
	TokenURL string `json:"tokenUrl,omitempty"`
}

// ID gets the id of this subtype
func (m *OAuthClientAuthPolicy) ID() *string {
	return m.idField
}

// SetID sets the id of this subtype
func (m *OAuthClientAuthPolicy) SetID(val *string) {
	m.idField = val
}

// Policy gets the policy of this subtype
func (m *OAuthClientAuthPolicy) Policy() *string {
	return m.policyField
}

// SetPolicy sets the policy of this subtype
func (m *OAuthClientAuthPolicy) SetPolicy(val *string) {
	m.policyField = val
}

// Type gets the type of this subtype
func (m *OAuthClientAuthPolicy) Type() string {
	return "OAuthClientAuthPolicy"
}

// SetType sets the type of this subtype
func (m *OAuthClientAuthPolicy) SetType(val string) {
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *OAuthClientAuthPolicy) UnmarshalJSON(raw []byte) error {
	var data struct {

		// The authorization URL
		// Max Length: 256
		// Pattern: ^[\w-_\:\.\?\/]*$
		AuthorizationURL string `json:"authorizationUrl,omitempty"`

		// The OAuth flows
		// Required: true
		// Max Items: 30
		// Min Items: 1
		Flows []string `json:"flows"`

		// The location of oauth token
		// Max Length: 100
		// Pattern: ^[\w-_\:\.\/]*$
		Location *string `json:"location,omitempty"`

		// Scopes that should be present in access token
		Scopes []*Scope `json:"scopes"`

		// The token URL
		// Max Length: 256
		// Pattern: ^[\w-_\:\.\/]*$
		TokenURL string `json:"tokenUrl,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		ID *string `json:"id"`

		Policy *string `json:"policy"`

		Type string `json:"type"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result OAuthClientAuthPolicy

	result.idField = base.ID

	result.policyField = base.Policy

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.AuthorizationURL = data.AuthorizationURL
	result.Flows = data.Flows
	result.Location = data.Location
	result.Scopes = data.Scopes
	result.TokenURL = data.TokenURL

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m OAuthClientAuthPolicy) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// The authorization URL
		// Max Length: 256
		// Pattern: ^[\w-_\:\.\?\/]*$
		AuthorizationURL string `json:"authorizationUrl,omitempty"`

		// The OAuth flows
		// Required: true
		// Max Items: 30
		// Min Items: 1
		Flows []string `json:"flows"`

		// The location of oauth token
		// Max Length: 100
		// Pattern: ^[\w-_\:\.\/]*$
		Location *string `json:"location,omitempty"`

		// Scopes that should be present in access token
		Scopes []*Scope `json:"scopes"`

		// The token URL
		// Max Length: 256
		// Pattern: ^[\w-_\:\.\/]*$
		TokenURL string `json:"tokenUrl,omitempty"`
	}{

		AuthorizationURL: m.AuthorizationURL,

		Flows: m.Flows,

		Location: m.Location,

		Scopes: m.Scopes,

		TokenURL: m.TokenURL,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		ID *string `json:"id"`

		Policy *string `json:"policy"`

		Type string `json:"type"`
	}{

		ID: m.ID(),

		Policy: m.Policy(),

		Type: m.Type(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this o auth client auth policy
func (m *OAuthClientAuthPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorizationURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlows(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScopes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTokenURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OAuthClientAuthPolicy) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID()); err != nil {
		return err
	}

	if err := validate.MinLength("id", "body", *m.ID(), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", *m.ID(), 100); err != nil {
		return err
	}

	if err := validate.Pattern("id", "body", *m.ID(), `^[\w-_\:\.\/]*$`); err != nil {
		return err
	}

	return nil
}

func (m *OAuthClientAuthPolicy) validatePolicy(formats strfmt.Registry) error {

	if err := validate.Required("policy", "body", m.Policy()); err != nil {
		return err
	}

	if err := validate.MinLength("policy", "body", *m.Policy(), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("policy", "body", *m.Policy(), 100); err != nil {
		return err
	}

	if err := validate.Pattern("policy", "body", *m.Policy(), `^[\w-_\:\.\/]*$`); err != nil {
		return err
	}

	return nil
}

func (m *OAuthClientAuthPolicy) validateAuthorizationURL(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthorizationURL) { // not required
		return nil
	}

	if err := validate.MaxLength("authorizationUrl", "body", m.AuthorizationURL, 256); err != nil {
		return err
	}

	if err := validate.Pattern("authorizationUrl", "body", m.AuthorizationURL, `^[\w-_\:\.\?\/]*$`); err != nil {
		return err
	}

	return nil
}

var oAuthClientAuthPolicyFlowsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["implicit","password","application","accessCode"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		oAuthClientAuthPolicyFlowsItemsEnum = append(oAuthClientAuthPolicyFlowsItemsEnum, v)
	}
}

func (m *OAuthClientAuthPolicy) validateFlowsItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, oAuthClientAuthPolicyFlowsItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *OAuthClientAuthPolicy) validateFlows(formats strfmt.Registry) error {

	if err := validate.Required("flows", "body", m.Flows); err != nil {
		return err
	}

	iFlowsSize := int64(len(m.Flows))

	if err := validate.MinItems("flows", "body", iFlowsSize, 1); err != nil {
		return err
	}

	if err := validate.MaxItems("flows", "body", iFlowsSize, 30); err != nil {
		return err
	}

	for i := 0; i < len(m.Flows); i++ {

		// value enum
		if err := m.validateFlowsItemsEnum("flows"+"."+strconv.Itoa(i), "body", m.Flows[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *OAuthClientAuthPolicy) validateLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("location", "body", *m.Location, 100); err != nil {
		return err
	}

	if err := validate.Pattern("location", "body", *m.Location, `^[\w-_\:\.\/]*$`); err != nil {
		return err
	}

	return nil
}

func (m *OAuthClientAuthPolicy) validateScopes(formats strfmt.Registry) error {

	if swag.IsZero(m.Scopes) { // not required
		return nil
	}

	for i := 0; i < len(m.Scopes); i++ {
		if swag.IsZero(m.Scopes[i]) { // not required
			continue
		}

		if m.Scopes[i] != nil {
			if err := m.Scopes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scopes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *OAuthClientAuthPolicy) validateTokenURL(formats strfmt.Registry) error {

	if swag.IsZero(m.TokenURL) { // not required
		return nil
	}

	if err := validate.MaxLength("tokenUrl", "body", m.TokenURL, 256); err != nil {
		return err
	}

	if err := validate.Pattern("tokenUrl", "body", m.TokenURL, `^[\w-_\:\.\/]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this o auth client auth policy based on the context it is used
func (m *OAuthClientAuthPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateScopes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *OAuthClientAuthPolicy) contextValidateScopes(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Scopes); i++ {

		if m.Scopes[i] != nil {
			if err := m.Scopes[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("scopes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *OAuthClientAuthPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *OAuthClientAuthPolicy) UnmarshalBinary(b []byte) error {
	var res OAuthClientAuthPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
