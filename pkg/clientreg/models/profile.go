// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Profile profile
//
// swagger:discriminator Profile type
type Profile interface {
	runtime.Validatable
	runtime.ContextValidatable

	// The id of the application to which this profile belongs to
	// Max Length: 32
	// Min Length: 32
	ApplicationID() string
	SetApplicationID(string)

	// The description of the profile
	// Max Length: 350
	// Pattern: ^[ -~\s]*$
	Description() string
	SetDescription(string)

	// Flag to indicate if this profile is enabled or not
	Enabled() *bool
	SetEnabled(*bool)

	// The id of the profile
	// Max Length: 32
	// Min Length: 32
	ID() string
	SetID(string)

	// metadata
	Metadata() *AuditMetadata
	SetMetadata(*AuditMetadata)

	// The profile name
	// Required: true
	// Max Length: 100
	// Min Length: 1
	Name() *string
	SetName(*string)

	// Type of the profile
	// Required: true
	// Enum: [SSHPublicKeyProfile PublicCertificateProfile AuthenticationProfile SFTPProfile FTPProfile JWTKeyProfile OAuthClientProfile CFTProfile]
	Type() string
	SetType(string)

	// AdditionalProperties in base type shoud be handled just like regular properties
	// At this moment, the base type property is pushed down to the subtype
}

type profile struct {
	applicationIdField string

	descriptionField string

	enabledField *bool

	idField string

	metadataField *AuditMetadata

	nameField *string

	typeField string
}

// ApplicationID gets the application Id of this polymorphic type
func (m *profile) ApplicationID() string {
	return m.applicationIdField
}

// SetApplicationID sets the application Id of this polymorphic type
func (m *profile) SetApplicationID(val string) {
	m.applicationIdField = val
}

// Description gets the description of this polymorphic type
func (m *profile) Description() string {
	return m.descriptionField
}

// SetDescription sets the description of this polymorphic type
func (m *profile) SetDescription(val string) {
	m.descriptionField = val
}

// Enabled gets the enabled of this polymorphic type
func (m *profile) Enabled() *bool {
	return m.enabledField
}

// SetEnabled sets the enabled of this polymorphic type
func (m *profile) SetEnabled(val *bool) {
	m.enabledField = val
}

// ID gets the id of this polymorphic type
func (m *profile) ID() string {
	return m.idField
}

// SetID sets the id of this polymorphic type
func (m *profile) SetID(val string) {
	m.idField = val
}

// Metadata gets the metadata of this polymorphic type
func (m *profile) Metadata() *AuditMetadata {
	return m.metadataField
}

// SetMetadata sets the metadata of this polymorphic type
func (m *profile) SetMetadata(val *AuditMetadata) {
	m.metadataField = val
}

// Name gets the name of this polymorphic type
func (m *profile) Name() *string {
	return m.nameField
}

// SetName sets the name of this polymorphic type
func (m *profile) SetName(val *string) {
	m.nameField = val
}

// Type gets the type of this polymorphic type
func (m *profile) Type() string {
	return "Profile"
}

// SetType sets the type of this polymorphic type
func (m *profile) SetType(val string) {
}

// UnmarshalProfileSlice unmarshals polymorphic slices of Profile
func UnmarshalProfileSlice(reader io.Reader, consumer runtime.Consumer) ([]Profile, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []Profile
	for _, element := range elements {
		obj, err := unmarshalProfile(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalProfile unmarshals polymorphic Profile
func UnmarshalProfile(reader io.Reader, consumer runtime.Consumer) (Profile, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalProfile(data, consumer)
}

func unmarshalProfile(data []byte, consumer runtime.Consumer) (Profile, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the type property.
	var getType struct {
		Type string `json:"type"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("type", "body", getType.Type); err != nil {
		return nil, err
	}

	// The value of type is used to determine which type to create and unmarshal the data into
	switch getType.Type {
	case "AuthenticationProfile":
		var result AuthenticationProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "CFTProfile":
		var result CFTProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "FTPProfile":
		var result FTPProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "JWTKeyProfile":
		var result JWTKeyProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "OAuthClientProfile":
		var result OAuthClientProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "Profile":
		var result profile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "PublicCertificateProfile":
		var result PublicCertificateProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "SFTPProfile":
		var result SFTPProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	case "SSHPublicKeyProfile":
		var result SSHPublicKeyProfile
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil
	}
	return nil, errors.New(422, "invalid type value: %q", getType.Type)
}

// Validate validates this profile
func (m *profile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *profile) validateApplicationID(formats strfmt.Registry) error {
	if swag.IsZero(m.ApplicationID()) { // not required
		return nil
	}

	if err := validate.MinLength("applicationId", "body", m.ApplicationID(), 32); err != nil {
		return err
	}

	if err := validate.MaxLength("applicationId", "body", m.ApplicationID(), 32); err != nil {
		return err
	}

	return nil
}

func (m *profile) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(m.Description()) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", m.Description(), 350); err != nil {
		return err
	}

	if err := validate.Pattern("description", "body", m.Description(), `^[ -~\s]*$`); err != nil {
		return err
	}

	return nil
}

func (m *profile) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID()) { // not required
		return nil
	}

	if err := validate.MinLength("id", "body", m.ID(), 32); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", m.ID(), 32); err != nil {
		return err
	}

	return nil
}

func (m *profile) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.Metadata()) { // not required
		return nil
	}

	if m.Metadata() != nil {
		if err := m.Metadata().Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *profile) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name(), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name(), 100); err != nil {
		return err
	}

	return nil
}

var profileTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SSHPublicKeyProfile","PublicCertificateProfile","AuthenticationProfile","SFTPProfile","FTPProfile","JWTKeyProfile","OAuthClientProfile","CFTProfile"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		profileTypeTypePropEnum = append(profileTypeTypePropEnum, v)
	}
}

const (

	// ProfileTypeSSHPublicKeyProfile captures enum value "SSHPublicKeyProfile"
	ProfileTypeSSHPublicKeyProfile string = "SSHPublicKeyProfile"

	// ProfileTypePublicCertificateProfile captures enum value "PublicCertificateProfile"
	ProfileTypePublicCertificateProfile string = "PublicCertificateProfile"

	// ProfileTypeAuthenticationProfile captures enum value "AuthenticationProfile"
	ProfileTypeAuthenticationProfile string = "AuthenticationProfile"

	// ProfileTypeSFTPProfile captures enum value "SFTPProfile"
	ProfileTypeSFTPProfile string = "SFTPProfile"

	// ProfileTypeFTPProfile captures enum value "FTPProfile"
	ProfileTypeFTPProfile string = "FTPProfile"

	// ProfileTypeJWTKeyProfile captures enum value "JWTKeyProfile"
	ProfileTypeJWTKeyProfile string = "JWTKeyProfile"

	// ProfileTypeOAuthClientProfile captures enum value "OAuthClientProfile"
	ProfileTypeOAuthClientProfile string = "OAuthClientProfile"

	// ProfileTypeCFTProfile captures enum value "CFTProfile"
	ProfileTypeCFTProfile string = "CFTProfile"
)

// prop value enum
func (m *profile) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, profileTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

// ContextValidate validate this profile based on the context it is used
func (m *profile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *profile) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.Metadata() != nil {
		if err := m.Metadata().ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}
